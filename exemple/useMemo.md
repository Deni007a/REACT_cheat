### тонкости useMemo:
- Кэширование значений: useMemo возвращает мемоизированное значение, которое пересчитывается только при изменении 
указанных зависимостей.


- Оптимизация производительности: Используется для избежания повторных вычислений, которые могут быть затратными по 
времени или ресурсам.


- Зависимости: Вы указываете массив зависимостей. Если ни одна из зависимостей не изменилась, *useMemo* возвращает 
закэшированное значение. Если зависимости изменились, вычисление выполняется заново.


- Использование с осторожностью: Не стоит использовать *useMemo* для всех вычислений. Он полезен только в случаях, 
когда вычисления действительно дорогостоящие или когда они вызывают проблемы с производительностью.

---

Мемоизации довольно дорогая операция так что реализовывать ее нужно только когда действительно нужно!!!

---
```jsx
import { useMemo } from 'react';

function MyComponent({ items }) {
  // Функция для вычисления значения
  const calculateValue = (items) => {
    // Представьте, что здесь тяжелые вычисления
    return items.reduce((sum, item) => sum + item.value, 0);
  };

  // Мемоизация вычисленного значения
  const memoizedValue = useMemo(() => calculateValue(items), [items]);

  return (
    <div>
      Мемоизированное значение: {memoizedValue}
    </div>
  );
}
```
- ***useMemo*** принимает два аргумента: функцию, которая возвращает запомненное значение, и массив зависимостей.


- Функция будет перезапущена только тогда, когда значения зависимостей изменятся. В этом случае, *calculateValue(items)*
будет выполнена только тогда, когда items изменятся.


- Если зависимости не изменились, *useMemo* вернет предыдущее запомненное значение без повторного вычисления функции.
- 
---
#### Когда использовать useMemo?

1. Дорогостоящие вычисления: Если у вас есть вычисления, которые занимают много времени (например, сложные 
математические операции, обработка больших массивов данных и т.д.).


2. Оптимизация рендеров: Если вычисления зависят от пропсов или состояния, и вы хотите избежать повторных вычислений 
при каждом рендере.


3. Стабилизация ссылок: Если вы возвращаете объект, массив или функцию, и хотите избежать создания новой ссылки при 
каждом рендере (это может быть полезно для оптимизации дочерних компонентов, которые зависят от стабильности ссылок).

#### Когда не использовать useMemo?
1. Простые вычисления: Если вычисления простые и быстрые, использование useMemo может добавить ненужную сложность.


2. Избыточное использование: Не стоит оборачивать всё в useMemo, так как это может привести к ухудшению читаемости 
кода и даже к снижению производительности из-за накладных расходов на мемоизацию.